#!/usr/bin/perl -w
#
# reaver:  Kill any processes that are not owned by users with jobs assigned
#          to this node.
# Copyright 2006 Ohio Supercomputer Center
# Revision info:
# $HeadURL$
# $Revision$
# $Date$
#
# Usage:  all -j$PBS_JOBID -p /usr/local/sbin/reaver [jobid [jobids...]]
#
# jobid - jobid to clean up
#
# Must be run as root
# Intended to be run inside a PBS job epilogue
#
# Why is this called "reaver" and not "reaper"?  Because I like
# the TV show "Firefly", that's why. :)  --troy
#
use strict;
use POSIX();

# Turn off output buffering so that "sleep" calls don't cause a delay
# on standard output
$|=1;

# uids below this are assumed to be system accounts
my $sysuid_threshold=100;

# regexp of usernames with uids above $sysuid_threshold that are allowed
# to have processes running on a node without a PBS job
my $safelist="arraysvcs|oscmon|decypher";

# append to $safelist the names of all users who have jobs currently running
# on this host
# first, we have to get a list of all the PBS jobids assigned to this host
my $hostname=`hostname`;
chomp($hostname);
my $joblist=undef;

# Guess absolute path to command if it isn't already in $PATH
eval
  {
    no warnings "exec";
    open(PBSNODES, "pbsnodes -a |")
    or open(PBSNODES, "/usr/local/pbs/bin/pbsnodes -a |");
  } or die "Cannot run pbsnodes command: $!";

while (<PBSNODES>)
  {
    # pbsnodes -a output looks like this
    # host
    #      indented list of key = value pairs for host
    # blank line
    #
    # so we want to find $hostname in the list and then get the value
    # of "jobs = " under that
    chomp;
    if ( $_ eq $hostname )
      {
        $joblist="";
	while (<PBSNODES>)
	  {
	    chomp;
	    my ($key,$value) = split(/ \= /);
	    last unless $key;
	    $key =~ s/^ *//g;
	    if ( $key eq "jobs" )
	      {
		$joblist=$value;
		$joblist =~ s/[0-9]+\///g;
		$joblist =~ s/\,//g;
		last;
	      }
	  }
	last;
      }
  }
close(PBSNODES);
die "pbsnodes failure" if ( ($?>>8)!=0 );

die "Host $hostname not found in pbsnodes output.\n" unless defined($joblist);

if ( $joblist ne "" )
  {
    my @alljobs = split(/ /,$joblist);
    # there may be duplicates in the job list; extract unique values
    # using method taken from online version of O'Reilly's Perl Cookbook
    my %seen = ();
    foreach my $item (@alljobs) {
      $seen{$item}++;
    }
    my @jobs = keys %seen;
    print "Running jobs:  @jobs\n";
    
    # remove from @jobs any jobids given on the command line
    if ( defined($ARGV[0]) )
      {
	my $ptn="";
	foreach my $jobid ( @ARGV )
	  {
	    if ( $ptn eq "" )
	      {
		$ptn = $jobid;
	      }
	    else
	      {
		$ptn .= "|$jobid"
	      }
	  }
	if ( $ptn ne "" )
	  {
	    @alljobs=@jobs;
	    @jobs=();
	    for ( my $i=0; $i<=$#alljobs; $i++ )
	      {
		if ( !($alljobs[$i] =~ /^($ptn)/) )
		  {
		    push(@jobs,$alljobs[$i]);
		  }
	      }
	  }
      }
      
    # now that we have a list of unique jobids, we need to get their
    # usernames and add them to $safelist
    print "Safe jobs:  ";
    if ( @jobs )
      {
        eval {
            no warnings "exec";
            open(QSTAT,"qstat @jobs |")
            or open(QSTAT,"/usr/local/pbs/bin/qstat @jobs |");
        } or die "Cannot run qstat command: $!";
	# skip 1st 2 lines of qstat output -- it's just headers
	<QSTAT>;
	<QSTAT>;
	while (<QSTAT>)
	  {
	    my ($jobid,$jobname,$user,$time,$status,$queue)=split(/ +/);
	    print "$jobid($user) ";
	    if ( ! ($safelist =~ /$user/) )
	      {
		if ( $safelist eq "" )
		  {
		    $safelist = "$user";
		  }
		else
		  {
		    $safelist .= "|$user";
		  }
	      }
	  }
	close(QSTAT);
	die "qstat failure" if ( ($?>>8)!=0 );
      }
    print "\n";
  }
else
  {
    print "Running jobs:  (none)\n";
  }  
  
if ( $safelist ne "" )
  {
    print "Safe users:  $safelist\n";
  }

# find all the target pids
my @pids=();
open(PS,"ps -A -o pid,state,uid,user,args |");
# snarf the 1st line
<PS>;
print "Stray processes:  ";
while (<PS>)
  {
    chomp;
    my ($pid,$state,$uid,$user,$command)=split(' ', $_, 5);
    if ( ($uid > $sysuid_threshold) && !($user =~ /^($safelist)$/) && ($uid!=$>) )
      {
	push(@pids,$pid);
	printf "\n%8d %s %-8.8s %-10.50s", $pid, $state, $user, $command;
      }
  }
print "(none)" unless @pids;
print "\n";
close(PS);
die "ps failure" if ( ($?>>8)!=0 );

# pull the trigger
if ( @pids && ($>==0))
  {
    # terminate-with-extreme-prejudice version
    # the CONT signal is needed to reawaken processes that are
    # in a breakpoint in a debugger
    print "Sending SIGCONT...\n";
    kill(&POSIX::SIGCONT,@pids);
    sleep(1);
    print "Sending SIGTERM...\n";
    kill(&POSIX::SIGTERM,@pids);
    sleep(5);
    print "Sending SIGKILL...\n";
    kill(&POSIX::SIGKILL,@pids);
  }
