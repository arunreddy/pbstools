#!/usr/bin/python
#
# job-vm-launch:  Launch a VM image inside a PBS job
# Copyright 2013, 2014, University of Tennessee
#
# License:  GNU GPL v2; see ../COPYING for details.
# Revision info:
# $HeadURL$
# $Revision$
# $Date$
#
# Usage: job-vm-launch [args] <vm-image-file>
#
# Arguments:
#
# Examples:
#
#
import getopt
import libvirt
import os
import re
import signal
import socket
import sys
import time
import uuid
from xml.dom import minidom,ext


global cloneimg
global exitcode
global hypervisor
global conn
global keepclone
global log
global vmimage
global vmname


def connect(hypervisor):
    conn = libvirt.open(hypervisor)
    if ( conn is None ):
        log.write("Failed to connect to hypervisor "+hypervisor+"\n")
        sys.exit(-1)
    return conn


def cleanup(signal,frame):
    global conn
    if ( vmname ):
        if ( conn is None ):
            conn = connect(hypervisor)
        try:
            guest = conn.lookupByName(vmname)
        except:
            log.write("cleanup:  Could not find VM "+vmname+"\n")
            sys.exit(-1)
        if ( guest.isActive() ): 
            log.write("Shutting down guest "+vmname+"\n")
            guest.shutdown()
            guest.destroy()
        if ( keepguest ):
            log.write("Keeping guest "+vmname+"\n")
        else:
            log.write("Removing guest "+vmname+"\n")
            guest.undefine()
    if ( cloneimg and not keepclone and os.path.exists(vmimage) ):
        log.write("Deleting clone image "+vmimage+"\n")
        os.unlink(vmimage)
    elif ( cloneimg and keepclone and os.path.exists(vmimage) ):
        log.write("Keeping clone image "+vmimage+"\n")
    exit(exitcode)


def usage(exitcode):
    sys.stderr.write("Usage:  job-vm-launch [args] <vm-image-file>\n")
    sys.exit(exitcode)


# misc default settings
log = sys.stdout
show_usage = False
exitcode=0
diskbus = "virtio"
diskformat = "raw"
ostype = "linux"
osvariant = None
cloneimg = False
keepclone = False
keepguest = False
block = True
otherdisks = []
bootopts = "hd"
networkopts = None
cputype = "host"
cdrom = None
location = None
vmimage = None
floppy = None
graphics = None
conn = None


# main program begins here

# find cpuset/cgroup root, if any
cpusetroot = None
if ( os.path.exists("/dev/cpuset") ):
    cpusetroot = "/dev/cpuset"
elif ( os.path.exists("/sys/fs/cgroup/cpuset") ):
    cpusetroot = "/sys/fs/cgroup/cpuset"

# find cpuset, if any
cpuset = None
if ( os.path.exists("/proc/self/cpuset") ):
    cpuset = open("/proc/self/cpuset").read()[:-1]

hostname = socket.gethostname()
jobid = None
if ( "PBS_JOBID" in os.environ ):
    jobid = os.environ["PBS_JOBID"]
else:
    sys.stderr.write("Not in a PBS job, exiting!\n")
    sys.exit(-1)

# figure out a default guest name
vmnum = 0
hypervisor = "qemu:///session"
conn = connect(hypervisor)
for vmid in conn.listDomainsID():
    thisvm = conn.lookupByID(vmid).name()
    if ( jobid+"-"+hostname+"-vm" in thisvm ):
        m = re.match("^"+jobid+"-"+hostname+"-vm(\d+)",thisvm)
        thisvmnum = int(m.group(1))
        if ( thisvmnum>=vmnum ):
            vmnum=thisvmnum+1
vmname = jobid+"-"+hostname+"-vm"+str(vmnum)
conn.close()
conn = None

# figure out number of virtual cores
# default to 1, just in case nothing else is set
vcores = 0
# look at cpuset/cgroup, if available
if ( cpusetroot is not None and cpuset is not None and
     ( os.path.exists(cpusetroot+"/"+cpuset+"/cpus") or
       os.path.exists(cpusetroot+"/"+cpuset+"/cpuset.cpus") ) ):
    fd = None
    if ( os.path.exists(cpusetroot+"/"+cpuset+"/cpus") ):
        fd = open(cpusetroot+"/"+cpuset+"/cpus")
    elif ( os.path.exists(cpusetroot+"/"+cpuset+"/cpuset.cpus") ):
        fd = open(cpusetroot+"/"+cpuset+"/cpuset.cpus")
    if ( fd is not None ):
        cpus = fd.read().rstrip()
        elts = cpus.split(",")
        for elt in elts:
            if ( "-" in elt ):
                [start,end] = elt.split("-")
                vcores += int(end)-int(start)+1
            else:
                vcores += 1
        fd.close()
    if ( vcores==0 ):
        vcores = 1
# if not, check PBS environment
elif ( "PBS_NUM_PPN" in os.environ.keys() ):
    vcores = int(os.environ["PBS_NUM_PPN"])

# figure out my memory limit (in MB)
# default to 1GB, just in case nothing else is set
memlimitmb = 1024
# look for cpuset/cgroup mem limit
if ( cpusetroot is not None and cpuset is not None and
     os.path.exists(cpusetroot+"/"+cpuset+"/memory.limit_in_bytes") ):
    fd = open(cpusetroot+"/"+cpuset+"/memory.limit_in_bytes")
    cgmemlimit = int(str(fd.read()).rstrip())
    fd.close()
    # cgroup mem is in bytes
    memlimitmb = cgmemlimit/(1024*1024)
else:
# if the cpuset/cgroup is no help, see if the job has a mem limit set
# also look for a core count if there's not one already set
    qmlimit = None
    qstatf = "qstat -f "+os.environ['PBS_JOBID']
    fd = os.popen(qstatf)
    for line in fd.readlines():
        if ( "Resource_List.mem" in line ):
            elt = (line.rstrip()).split()
            if ( len(elt)>=2 ):
                qmlimit = elt[2]
        elif ( "Resource_List.nodes" in line and vcores==0 ):
            elt = (line.rstrip()).split()
            if ( len(elt)>=2 ):
                # handle PBS nodes={#,host)[:ppn=#][:gpus=#][:feature][+...]
                # syntax
                nodes = elt[2].split("+")
                myvcores = vcores
                for node in nodes:
                    nelts = node.split(":")
                    for nelt in nelts[1:]:
                        if ( "ppn=" in nelt ):
                            if ( nelts[0] in hostname ):
                                myvcores = int((nelt.split("="))[1])
                                break
                                break
                            else:
                                myvcores = max(myvcores,int((nelt.split("="))[1]))
                if ( myvcores>vcores ):
                    vcores = myvcores
    fd.close()
    if ( qmlimit is not None ):
        # convert PBS' ####[kMGT][BW] syntax to MB
        m = re.match("^(\d+)([KkMmGgTt]{0,1})([BbWw])$",qmlimit)
        base = int(m.group(1))
        mult = 1.0/(1024*1024)
        if ( m.group(2) and ( m.group(2)=="K" or m.group(2)=="k" ) ):
            mult = 1.0/1024
        elif ( m.group(2) and ( m.group(2)=="M" or m.group(2)=="m" ) ):
            mult = 1
        elif ( m.group(2) and ( m.group(2)=="G" or m.group(2)=="g" ) ):
            mult = 1024
        elif ( m.group(2) and ( m.group(2)=="T" or m.group(2)=="t" ) ):
            mult = 1024*1024
        unit = 1
        if ( m.group(3)=="W" or m.group(3)=="w" ):
            unit = 8
        memlimitmb = int(base*mult*unit)

# command line argument handling
try:
    opts, args = getopt.getopt(sys.argv[1:],
                               "B:Cc:dF:f:hL:l:Nn:o:r:w:",
                               ["boot=","cdrom=","clone-image","connect=","cpu=","debug","disk=","disk-bus=s","disk-format=","file=","floppy=","graphics=","help","image=","keep-clone","keep-guest","location=","log=","name=","network=","no-block","os-type=","os-variant=","ram=","vcpus="])
except getopt.GetoptError, err:
    sys.stderr.write(str(err)+"\n\n")
    usage(-1)
if opts == [] and args == []:
    show_usage = True
if ( not show_usage ):
    for opt in opts:
        if ( opt[0]=="-B" or opt[0]=="--disk-bus" ):
            diskbus = opt[1]
        if ( opt[0]=="-C" or opt[0]=="--clone-image" ):
            cloneimg = True
        if ( opt[0]=="-c" or opt[0]=="--cdrom" ):
            cdrom = opt[1]
        if ( opt[0]=="-d" or opt[0]=="--debug" ):
            debug = True
        if ( opt[0]=="-F" or opt[0]=="--disk-format" ):
            diskformat = opt[1]
        if ( opt[0]=="-f" or opt[0]=="--file" or opt[0]=="--image" ):
            vmimage = opt[1]
        if ( opt[0]=="-h" or opt[0]=="--help" ):
            show_usage = True
        if ( opt[0]=="-L" or opt[0]=="--log" ):
            logfile = opt[1]
            try:
                log = open(logfile,'w')
            except IOError, (errno, strerror):
                sys.stderr.write("Can't open "+logfile+" for writing:  "+strerror+" (errno="+str(errno)+")\n")
                pass
        if ( opt[0]=="-l" or opt[0]=="--location" ):
            location = opt[1]
        if ( opt[0]=="-N" or opt[0]=="--no-block" ):
            block = False
        if ( opt[0]=="-n" or opt[0]=="--name" ):
            vmname = opt[1]
        if ( opt[0]=="-o" or opt[0]=="--os-type" ):
            ostype = opt[1]
        if ( opt[0]=="-r" or opt[0]=="--ram" ):
            memlimitmb = int(opt[1])
        if ( opt[0]=="-w" or opt[0]=="--network" ):
            networkopts = opt[1]
        if ( opt[0]=="--boot" ):
            bootopts = opt[1]
        if ( opt[0]=="--connect" ):
            hypervisor = opt[1]
        if ( opt[0]=="--cpu" ):
            cputype = opt[1]
        if ( opt[0]=="--disk" ):
            otherdisks.append(opt[1])
        if ( opt[0]=="--floppy" ):
            floppy = opt[1]
        if ( opt[0]=="--graphics" ):
            graphics = opt[1]
        if ( opt[0]=="--keep-clone" ):
            keepclone = True
        if ( opt[0]=="--keep-guest" ):
            keepguest = True
        if ( opt[0]=="--os-variant" ):
            osvariant = opt[1]
        if ( opt[0]=="--vcpus" ):
            vcores = int(opt[1])
if ( show_usage ):
    usage(exitcode)
log.flush()

# at this point, there had better only be at most one element in args, and
# it had better be a VM image...
if ( len(args)>1 ):
    sys.stderr.write("Too many arguments in \""+" ".join(sys.argv)+"\"\n")
    usage(-2)
if ( vmimage is None ):
    vmimage = args[0]
if ( not os.path.exists(vmimage) ):
    sys.stderr.write("VM image not found:  "+vmimage+"\n")
    sys.exit(-4)

# clone the VM image, if needed
if ( cloneimg ):
    newimg = "/tmp/"+str(uuid.uuid3(uuid.NAMESPACE_DNS,vmname))+".img"
    log.write("Cloning "+vmimage+" into "+newimg+"\n")
    os.system("dd if="+vmimage+" of="+newimg+" bs=1M")
    vmimage = newimg

# connect to the hypervisor
if ( conn is None ):
    conn = connect(hypervisor)

# fork and start VM in child
childpid  = os.fork()
if ( childpid==0 ):
    # generate XML description of VM
    xml = minidom.Document()
    domnode = xml.createElement("domain")
    domnode.setAttribute("type","kvm")
    namenode = xml.createElement("name")
    namenode.appendChild(xml.createTextNode(vmname))
    domnode.appendChild(namenode)
    memnode = xml.createElement("memory")
    memnode.appendChild(xml.createTextNode(str(1024*memlimitmb)))
    domnode.appendChild(memnode)
    vcpunode = xml.createElement("vcpu")
    vcpunode.appendChild(xml.createTextNode(str(vcores)))
    domnode.appendChild(vcpunode)
    osnode = xml.createElement("os")
    ostypenode =  xml.createElement("type")
    ostypenode.setAttribute("arch","x86_64")
    ostypenode.appendChild(xml.createTextNode("hvm"))
    osnode.appendChild(ostypenode)
    osbootnode = xml.createElement("boot")
    if ( bootopts is None ):
        osbootnode.setAttribute("dev","hd")
    else:
        osbootnode.setAttribute("dev",bootopts.split(",")[0])
    osnode.appendChild(osbootnode)
    domnode.appendChild(osnode)
    featurenode = xml.createElement("features")
    featurenode.appendChild(xml.createElement("acpi"))
    featurenode.appendChild(xml.createElement("apic"))
    featurenode.appendChild(xml.createElement("pae"))
    domnode.appendChild(featurenode)
    # how to handle cpu features?
    clocknode = xml.createElement("clock")
    clocknode.setAttribute("offset","utc")
    domnode.appendChild(clocknode)
    offnode = xml.createElement("on_poweroff")
    offnode.appendChild(xml.createTextNode("destroy"))
    domnode.appendChild(offnode)
    rebootnode = xml.createElement("on_reboot")
    rebootnode.appendChild(xml.createTextNode("restart"))
    domnode.appendChild(rebootnode)
    crashnode = xml.createElement("on_crash")
    crashnode.appendChild(xml.createTextNode("restart"))
    domnode.appendChild(crashnode)
    devnode = xml.createElement("devices")
    emunode = xml.createElement("emulator")
    emunode.appendChild(xml.createTextNode("/bin/qemu-kvm"))
    devnode.appendChild(emunode)
    if ( floppy is not None ):
        floppynode = xml.createElement("disk")
        floppynode.setAttribute("type","file")
        floppynode.setAttribute("device","floppy")
        fdrvnode = xml.createElement("driver")
        fdrvnode.setAttribute("name","qemu")
        floppynode.appendChild(fdrvnode)
        fsrcnode = xml.createElement("source")
        fsrcnode.setAttribute("file",floppy)
        floppynode.appendChild(fsrcnode)
        ftgtnode = xml.createElement("target")
        ftgtnode.setAttribute("dev","fda")
        ftgtnode.setAttribute("bus","fdc")
        floppynode.appendChild(ftgtnode)
        devnode.appendChild(floppynode)
    disknode = xml.createElement("disk")
    disknode.setAttribute("type","file")
    disknode.setAttribute("device","disk")
    ddrvnode = xml.createElement("driver")
    ddrvnode.setAttribute("name","qemu")
    ddrvnode.setAttribute("type",diskformat)
    disknode.appendChild(ddrvnode)
    dsrcnode = xml.createElement("source")
    dsrcnode.setAttribute("file",vmimage)
    disknode.appendChild(dsrcnode)
    dtgtnode = xml.createElement("target")
    dtgtnode.setAttribute("dev","vda")
    dtgtnode.setAttribute("bus",diskbus)
    disknode.appendChild(dtgtnode)
    devnode.appendChild(disknode)
    # how to handle other disk devices?
    # how to handle MAC addresses?
    inputnode = xml.createElement("input")
    inputnode.setAttribute("type","mouse")
    inputnode.setAttribute("bus","ps2")
    devnode.appendChild(inputnode)
    graphicsnode = xml.createElement("graphics")
    if ( graphics is not None ):
        graphicsnode.setAttribute("type",graphics)
    else:
        graphicsnode.setAttribute("type","vnc")
    graphicsnode.setAttribute("port","-1")
    devnode.appendChild(graphicsnode)
    consolenode = xml.createElement("console")
    consolenode.setAttribute("type","pty")
    devnode.appendChild(consolenode)
    videonode = xml.createElement("video")
    modelnode = xml.createElement("model")
    modelnode.setAttribute("type","cirrus")
    videonode.appendChild(modelnode)
    devnode.appendChild(videonode)
    domnode.appendChild(devnode)
    xml.appendChild(domnode)
    #ext.PrettyPrint(xml)
    # virt-install is probably not the right way to do this, but AFAICT it's
    # the easiest way to create a guest and boot it all in one go
    cmd = "virt-install"
    args = [cmd,"--connect="+hypervisor,"--name="+vmname,"--accelerate",
            "--cpu="+cputype,"--vcpus="+str(vcores),"--ram="+str(memlimitmb),
            "--os-type="+ostype]
    if ( osvariant is not None ):
        args.append("--os-variant="+osvariant)
    if ( graphics is not None ):
        args.append("--graphics="+graphics)
    if ( cdrom is not None ):
        args.append("--cdrom="+cdrom)
    elif ( location is not None ):
        args.append("--location="+location)
    else:
        args.append("--import")
    if ( bootopts is not None ):
        args.extend(["--boot",bootopts])
    if ( floppy is not None ):
        args.extend(["--disk","path="+floppy+",device=floppy"])
    args.extend(["--disk","path="+vmimage+",device=disk,bus="+diskbus+",format="+diskformat])
    for disk in otherdisks:
        args.extend(["--disk",disk])
    if ( networkopts is not None ):
        args.extend(["--network",networkopts])
    # create VM domain (which will start it)
    log.write("Starting VM image "+vmimage+" as guest domain "+vmname+" in hypervisor "+hypervisor+"\n")
    log.write(" ".join(args)+"\n")
    #sys.exit(0)
    os.execvp(cmd,args)

# put resulting process in cpuset, if possible
if ( os.path.exists(cpusetroot+"/"+cpuset+"/tasks") and
     os.access(cpusetroot+"/"+cpuset+"/tasks",os.W_OK) ):
    fd = open(cpusetroot+"/"+cpuset+"/tasks",'w')
    fd.write(str(childpid))
    fd.close()

# set signal handler in case the job ends before the VM shuts down
# or user hits ^C
signal.signal(signal.SIGINT,cleanup)
signal.signal(signal.SIGTERM,cleanup)

if ( block ):
    # wait on child
    status = os.waitpid(childpid,0)
    cleanup(None,None)
    exit(status[0])
else:
    # fork a copy of myself that sleeps indefinitely as a cleaner,
    # then exit main program
    cleanerpid = os.fork()
    if ( cleanerpid==0 ):
        while True:
            time.sleep(10)
    exit(exitcode)


